       ctl-Opt noMain option(*srcstmt: *nodebugio);

         // Create the module SQLSCALE1 using the command CRTSQLRPGI
         // Create the service program SQLSCALAR using the command
         //    CRTSRVPGM SRVPGM(SQLSCALAR/SQLSCALAR)
         //   MODULE(SQLSCALAR/SQLSCALE1)
         //   SRCFILE(SQLSCALAR)
         //   SRCMBR(SQLSCALAR)
         //   TEXT('RPGLE Wrappers for SQL Scalar Functions')

      /include SQLSCALAR,PSQLSCALE1

        //----------------------------------------------------------------------

       dcl-S rSQLCode  zoned(5);
       dcl-S rSQLState char(5);

        //----------------------------------------------------------------------

       dcl-Proc dummyProc;
          // Dummy procedure for set options
          exec SQL
            set option commit = *NONE,
                       naming = *SYS,
                       datFmt = *ISO;
       end-Proc;

        //----------------------------------------------------------------------


       dcl-Proc setCodes;
          rSQLCode = SQLCode;
          rSQLState = SQLState;
       end-Proc;

       dcl-Proc set_MaxLength;
          dcl-Pi *n int(10);
             checkLength  int(10) dim(10) const;
          end-Pi;

          dcl-S i         int(10);
          dcl-S maxLength int(10);

          for i = 1 to %elem(checkLength);
             if (maxLength < checkLength(i));
                maxLength = checkLength(i);
             endIf;
          endFor;
          return maxLength;

       end-Proc;

       dcl-Proc rSQL_SQLCode export;
          dcl-Pi *n zoned(5) end-Pi;

          return rSQLCode;
       end-Proc;


       dcl-Proc rSQL_SQLState export;
          dcl-Pi *n char(5) end-Pi;

          return rSQLState;
       end-Proc;


        //----------------------------------------------------------------------

       dcl-Proc rSQL_abs export;
          dcl-Pi *n zoned(30:10);
            numIn zoned(30:10) const;
          end-Pi;

          dcl-S numOut zoned(30:10);

          exec SQL
            values abs(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;


       dcl-Proc rSQL_acos export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values acos(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;


       dcl-Proc rSQL_antiLog export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values antiLog(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;


       dcl-Proc rSQL_ascii export;
          dcl-Pi *n int(5);
            charIn char(1) const;
          end-Pi;

          dcl-S numOut int(5);

          exec SQL
            values ascii(:charIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_asin export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values asin(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_atan export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values atan(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_atan2 export;
          dcl-Pi *n zoned(30:16);
            num_x_In zoned(30:16) const;
            num_y_In zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values atan2(:num_x_In, :num_y_In) into :numOut;
          setCodes();
          return numOut;
       end-Proc;


       dcl-Proc rSQL_atanh export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values atanh(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_bit_Length export;
          dcl-Pi *n packed(31);
            valueIn varchar(5000) const;
          end-Pi;

          dcl-S valueOut packed(30);

          exec SQL
            values bit_Length(:valueIn) into :valueOut;
          setCodes();
          return ValueOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_ceiling export;
          dcl-Pi *n int(20);
            valueIn zoned(30:15) const;
          end-Pi;

          dcl-S valueOut int(20);

          exec SQL
            values ceiling(:valueIn) into :valueOut;
          setCodes();
          return ValueOut;
       end-Proc;


       dcl-Proc rSQL_chr export;
          dcl-Pi *n char(1);
            numberIn int(5) const;
          end-Pi;

          dcl-S characterOut char(1);

          exec SQL
            values chr(:numberIn) into :characterOut;
          setCodes();
          return characterOut;
       end-Proc;

       dcl-Proc rSQL_coalesce export;
          dcl-Pi *n varchar(1000);
            value01In varchar(1000) const  options(*noPass: *Omit);
            value02In varchar(1000) const  options(*noPass: *Omit);
            value03In varchar(1000) const  options(*noPass: *Omit);
            value04In varchar(1000) const  options(*noPass: *Omit);
            value05In varchar(1000) const  options(*noPass: *Omit);
            value06In varchar(1000) const  options(*noPass: *Omit);
            value07In varchar(1000) const  options(*noPass: *Omit);
            value08In varchar(1000) const  options(*noPass: *Omit);
            value09In varchar(1000) const  options(*noPass: *Omit);
            value10In varchar(1000) const  options(*noPass: *Omit);
          end-Pi;

          dcl-S valueOut varchar(1000);
          dcl-S value01 varchar(1000);
          dcl-S value02 varchar(1000);
          dcl-S value03 varchar(1000);
          dcl-S value04 varchar(1000);
          dcl-S value05 varchar(1000);
          dcl-S value06 varchar(1000);
          dcl-S value07 varchar(1000);
          dcl-S value08 varchar(1000);
          dcl-S value09 varchar(1000);
          dcl-S value10 varchar(1000);

          if ((%parms() >= 1) and (%addr(value01In) <> *null));
             value01 = %trimR(value01In);
          endIf;
          if ((%parms() >= 2) and (%addr(value02In) <> *null));
             value02 = %trimR(value02In);
          endIf;
          if ((%parms() >= 3) and (%addr(value03In) <> *null));
             value03 = %trimR(value03In);
          endIf;
          if ((%parms() >= 4) and (%addr(value04In) <> *null));
             value04 = %trimR(value04In);
          endIf;
          if ((%parms() >= 5) and (%addr(value05In) <> *null));
             value05 = %trimR(value05In);
          endIf;
          if ((%parms() >= 6) and (%addr(value06In) <> *null));
             value06 = %trimR(value06In);
          endIf;
          if ((%parms() >= 7) and (%addr(value07In) <> *null));
             value07 = %trimR(value07In);
          endIf;
          if ((%parms() >= 8) and (%addr(value08In) <> *null));
             value08 = %trimR(value08In);
          endIf;
          if ((%parms() >= 9) and (%addr(value09In) <> *null));
             value09 = %trimR(value09In);
          endIf;
          if ((%parms() >= 10) and (%addr(value10In) <> *null));
             value10 = %trimR(value10In);
          endIf;

          exec SQL
            values coalesce(case :value01
                              when '' then cast(null as char)
                              else :value01 end,
                            case :value02
                              when '' then cast(null as char)
                              else :value02 end,
                            case :value03
                              when '' then cast(null as char)
                              else :value03 end,
                            case :value04
                              when '' then cast(null as char)
                              else :value04 end,
                            case :value05
                              when '' then cast(null as char)
                              else :value05 end,
                            case :value06
                              when '' then cast(null as char)
                              else :value06 end,
                            case :value07
                              when '' then cast(null as char)
                              else :value07 end,
                            case :value08
                              when '' then cast(null as char)
                              else :value08 end,
                            case :value09
                              when '' then cast(null as char)
                              else :value09 end,
                            case :value10
                              when '' then cast(null as char)
                              else :value10 end)
               into :valueOut;

          setCodes();
          return %trimR(valueOut);
       end-Proc;

       dcl-Proc rSQL_cos export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values cos(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_cosh export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values cosh(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_cot export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values cot(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_database export;
          dcl-Pi *n varchar(18);
          end-Pi;

          dcl-S databaseOut varchar(18);

          exec SQL
            values database() into :databaseOut;
          setCodes();
          return %trimR(databaseOut);
       end-Proc;

       dcl-Proc rSQL_dayName export;
          dcl-Pi *n varchar(15);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S textOut varchar(15);

          exec SQL
            values dayName(:dateIn) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_dayOfWeek export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values dayOfWeek(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

       dcl-Proc rSQL_dayOfWeek_ISO export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values dayOfWeek_ISO(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

       dcl-Proc rSQL_dayOfYear export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values dayOfYear(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

       dcl-Proc rSQL_decrypt_CHAR export;
          dcl-Pi *n varchar(30000);
            textIn     varchar(30064) const;
            passwordIn varchar(127)   const options(*noPass);
          end-Pi;

          dcl-S password varchar(127) inz('       ');
          dcl-S textOut  varchar(30000);

          if (%parms() < 2);
             exec SQL
               values decrypt_char(cast(:textIn as char(30064) for bit data))
                      into :textOut;
          else;
             password = %trimR(passwordIn);
             if (%len(password) < 6);
                %len(password) = 6;
             endIf;
             exec SQL
               values decrypt_char(cast(:textIn as char(30064) for bit data),
                                   :password) into :textOut;
          endIf;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_degrees export;
          dcl-Pi *n zoned(30:16);
            valueIn zoned(30:16) const;
          end-Pi;

          dcl-S valueOut zoned(30:16);

          exec SQL
            values round(degrees(:valueIn), 16) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_difference export;
          dcl-Pi *n int(5);
            string01 varchar(32000) const;
            string02 varchar(32000) const;
          end-Pi;

          dcl-S valueOut int(5);

          exec SQL
            values difference(:string01, :string01) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_encrypt_AES export;
          dcl-Pi *n varchar(30064);
            textIn     varchar(30000) const;
            passwordIn varchar(127)   const options(*noPass);
            hintIn     varchar(32)    const options(*noPass);
          end-Pi;

          dcl-S password varchar(127) inz('       ');
          dcl-S hint     varchar(32);
          dcl-S textOut  varchar(30064);

          if (%parms() > 1);
             password = %trimR(passwordIn);
             if (%len(password) < 6);
                %len(password) = 6;
             endIf;
          endIf;

          if (%parms() < 2);
             exec SQL
               values encrypt_AES(:textIn) into :textOut;
          elseIf (%parms() < 3);
             exec SQL
               values encrypt_AES(:textIn, :password) into :textOut;
          else;
             hint = %trimR(hintIn);
             exec SQL
               values encrypt_AES(:textIn, :password, :hint) into :textOut;
          endIf;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_encrypt_RC2 export;
          dcl-Pi *n varchar(30064);
            textIn     varchar(30000) const;
            passwordIn varchar(127)   const options(*noPass);
            hintIn     varchar(32)    const options(*noPass);
          end-Pi;

          dcl-S password varchar(127) inz('       ');
          dcl-S hint     varchar(32);
          dcl-S textOut  varchar(30064);

          if (%parms() > 1);
             password = %trimR(passwordIn);
             if (%len(password) < 6);
                %len(password) = 6;
             endIf;
          endIf;

          if (%parms() < 2);
             exec SQL
               values encrypt_RC2(:textIn) into :textOut;
          elseIf (%parms() < 3);
             exec SQL
               values encrypt_RC2(:textIn, :password) into :textOut;
          else;
             hint = %trimR(hintIn);
             exec SQL
               values encrypt_RC2(:textIn, :password, :hint) into :textOut;
          endIf;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_encrypt_TDES export;
          dcl-Pi *n varchar(30064);
            textIn     varchar(30000) const;
            passwordIn varchar(127)   const options(*noPass);
            hintIn     varchar(32)    const options(*noPass);
          end-Pi;

          dcl-S password varchar(127) inz('       ');
          dcl-S hint     varchar(32);
          dcl-S textOut  varchar(30064);

          if (%parms() > 1);
             password = %trimR(passwordIn);
             if (%len(password) < 6);
                %len(password) = 6;
             endIf;
          endIf;

          if (%parms() < 2);
             exec SQL
               values encrypt_TDES(:textIn) into :textOut;
          elseIf (%parms() < 3);
             exec SQL
               values encrypt_TDES(:textIn, :password) into :textOut;
          else;
             hint = %trimR(hintIn);
             exec SQL
               values encrypt_TDES(:textIn, :password, :hint) into :textOut;
          endIf;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_exp export;
          dcl-Pi *n zoned(30:16);
            intIn zoned(30:16) const;
          end-Pi;

          dcl-S valueOut zoned(30:16);

          exec SQL
            values round(exp(:intIn), 16) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_floor export;
          dcl-Pi *n int(20);
             numIn zoned(30: 15) const;
          end-Pi;

          dcl-S numOut int(20);

          exec SQL
            values floor(:numIn) into :numOut;
          setCodes();
          return numOut;

       end-Proc;

       dcl-Proc rSQL_full_Text_Date export;
          dcl-Pi *n varchar(100);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S textOut varchar(100);

          exec SQL
            values
              dayname(:dateIn) || ', ' || monthname(:dateIn) ||  ' ' ||
              day(:dateIn) || ', ' || year(:dateIn)  into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_getHint export;
          dcl-Pi *n varchar(32);
            textIn     varchar(30064) const;
          end-Pi;

          dcl-S textOut  varchar(32);

          exec SQL
            values getHint(cast(:textIn as char(30064) for bit data))
              into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_hex export;
          dcl-Pi *n varchar(32000);
            stringIn varchar(16000) const;
          end-Pi;

          dcl-S stringOut varchar(32000);

          exec SQL
            values hex(:stringIn) into :stringOut;
          setCodes();
          %len(stringOut) = %len(stringIn) * 2;
          return stringOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_ifNull export;
          dcl-Pi *n varchar(1000);
            value01In varchar(1000) const;
            value02In varchar(1000) const;
          end-Pi;

          dcl-S valueOut varchar(1000);

          exec SQL
            values ifNull(case :value01In
                            when '' then cast(null as char)
                            else :value01In end,
                          case :value02In
                            when '' then cast(null as char)
                            else :value02In end)
               into :valueOut;

          setCodes();
          return %trimR(valueOut);
       end-Proc;


        //----------------------------------------------------------------------

       dcl-Proc rSQL_julian_Day export;
          dcl-Pi *n int(10);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S daysOut int(10);

          exec SQL
            values julian_Day(:dateIn) into :daysOut;
          setCodes();
          return daysOut;
       end-Proc;


        //----------------------------------------------------------------------

       dcl-Proc rSQL_land export;
          dcl-Pi *n varchar(1000);
            var01 varchar(500) const;
            var02 varchar(500) const;
            var03 varchar(500) const options(*noPass);
            var04 varchar(500) const options(*noPass);
            var05 varchar(500) const options(*noPass);
            var06 varchar(500) const options(*noPass);
            var07 varchar(500) const options(*noPass);
            var08 varchar(500) const options(*noPass);
            var09 varchar(500) const options(*noPass);
            var10 varchar(500) const options(*noPass);
          end-Pi;

          dcl-S varOut varchar(1000) inz('');
          dcl-S maxArr int(10)       dim(10);
          dcl-S lenOut int(10);

          if (%parms() > 9);
             maxArr(10) = %len(var10);
          endIf;
          if (%parms() > 8);
             maxArr(9) = %len(var09);
          endIf;
          if (%parms() > 7);
             maxArr(8) = %len(var08);
          endIf;
          if (%parms() > 6);
             maxArr(7) = %len(var07);
          endIf;
          if (%parms() > 5);
             maxArr(6) = %len(var06);
          endIf;
          if (%parms() > 4);
             maxArr(5) = %len(var05);
          endIf;
          if (%parms() > 3);
             maxArr(4) = %len(var04);
          endIf;
          if (%parms() > 2);
             maxArr(3) = %len(var03);
          endIf;
          if (%parms() > 1);
             maxArr(2) = %len(var02);
          endIf;
          if (%parms() > 0);
             maxArr(1) = %len(var01);
          endIf;
          lenOut = set_MaxLength(maxArr);

          if (%parms < 3);
             exec SQL
               values land(:var01, :var02)
               into :varOut;
          elseIf (%parms < 4);
             exec SQL
               values land(:var01, :var02, :var03)
               into :varOut;
          elseIf (%parms < 5);
             exec SQL
               values land(:var01, :var02, :var03, :var04)
               into :varOut;
          elseIf (%parms < 6);
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05)
               into :varOut;
          elseIf (%parms < 7);
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05,
                          :var06)
               into :varOut;
          elseIf (%parms < 8);
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07)
               into :varOut;
          elseIf (%parms < 9);
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08)
               into :varOut;
          elseIf (%parms < 10);
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09)
               into :varOut;
          else;
             exec SQL
               values land(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09, :var10)
               into :varOut;
          endIf;

          setCodes();
          %len(varOut) = lenOut;
          return varOut;
       end-Proc;

       dcl-Proc rSQL_last_Day export;
          dcl-Pi *n date;
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dateOut date;

          exec SQL
            values last_Day(:dateIn) into :dateOut;
          setCodes();
          return dateOut;
       end-Proc;

       dcl-Proc rSQL_last_Day_Stamp export;
          dcl-Pi *n timestamp;
            stampIn timestamp const;
          end-Pi;

          dcl-S stampOut timestamp;

          exec SQL
            values last_Day(:stampIn) into :stampOut;
          setCodes();
          return stampOut;
       end-Proc;


       dcl-Proc rSQL_lcase export;
          dcl-Pi *n varchar(32000);
            textIn varchar(32000) const;
          end-Pi;

          dcl-S textOut varchar(32000);

          textOut = %trimR(textIn);
          exec SQL
            values lcase(:textOut) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_left export;
          dcl-Pi *n varchar(32000);
            stringIn    varchar(32000) const;
            forLengthIn int(10)        const;
          end-Pi;

          dcl-S stringOut varchar(32000);
          dcl-S getLength int(10);

          getLength = forLengthIn;
          if (%len(stringIn) < getLength);
             getLength = %len(stringIn);
          endIf;
          if (getLength > 0);
             exec SQL
               values left(:stringIn, :getLength) into :stringOut;
             setCodes();
          endIf;
          return %trimR(stringOut);
       end-Proc;

       dcl-Proc rSQL_ln export;
          dcl-Pi *n zoned(30:16);
            intIn zoned(30:16) const;
          end-Pi;

          dcl-S valueOut zoned(30:16);

          exec SQL
            values round(ln(:intIn), 16) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_log10 export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values log10(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_lnot export;
          dcl-Pi *n varchar(32000);
            stringIn varchar(32000) const;
          end-Pi;

          dcl-S stringOut varchar(32000);

          exec SQL
            values lnot(:stringIn) into :stringOut;
          setCodes();
          %len(stringOut) = %len(stringIn);
          return %trimR(stringOut);

       end-Proc;

       dcl-Proc rSQL_lor export;
          dcl-Pi *n varchar(1000);
            var01 varchar(500) const;
            var02 varchar(500) const;
            var03 varchar(500) const options(*noPass);
            var04 varchar(500) const options(*noPass);
            var05 varchar(500) const options(*noPass);
            var06 varchar(500) const options(*noPass);
            var07 varchar(500) const options(*noPass);
            var08 varchar(500) const options(*noPass);
            var09 varchar(500) const options(*noPass);
            var10 varchar(500) const options(*noPass);
          end-Pi;

          dcl-S varOut varchar(1000) inz('');
          dcl-S maxArr int(10)       dim(10);
          dcl-S lenOut int(10);

          if (%parms() > 9);
             maxArr(10) = %len(var10);
          endIf;
          if (%parms() > 8);
             maxArr(9) = %len(var09);
          endIf;
          if (%parms() > 7);
             maxArr(8) = %len(var08);
          endIf;
          if (%parms() > 6);
             maxArr(7) = %len(var07);
          endIf;
          if (%parms() > 5);
             maxArr(6) = %len(var06);
          endIf;
          if (%parms() > 4);
             maxArr(5) = %len(var05);
          endIf;
          if (%parms() > 3);
             maxArr(4) = %len(var04);
          endIf;
          if (%parms() > 2);
             maxArr(3) = %len(var03);
          endIf;
          if (%parms() > 1);
             maxArr(2) = %len(var02);
          endIf;
          if (%parms() > 0);
             maxArr(1) = %len(var01);
          endIf;
          lenOut = set_MaxLength(maxArr);

          if (%parms < 3);
             exec SQL
               values lor(:var01, :var02)
               into :varOut;
          elseIf (%parms < 4);
             exec SQL
               values lor(:var01, :var02, :var03)
               into :varOut;
          elseIf (%parms < 5);
             exec SQL
               values lor(:var01, :var02, :var03, :var04)
               into :varOut;
          elseIf (%parms < 6);
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05)
               into :varOut;
          elseIf (%parms < 7);
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05,
                          :var06)
               into :varOut;
          elseIf (%parms < 8);
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07)
               into :varOut;
          elseIf (%parms < 9);
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08)
               into :varOut;
          elseIf (%parms < 10);
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09)
               into :varOut;
          else;
             exec SQL
               values lor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09, :var10)
               into :varOut;
          endIf;

          setCodes();
          %len(varOut) = lenOut;
          return varOut;
       end-Proc;

       dcl-Proc rSQL_lower export;
          dcl-Pi *n varchar(32000);
            textIn varchar(32000) const;
          end-Pi;

          dcl-S textOut varchar(32000);

          textOut = %trimR(textIn);
          exec SQL
            values lower(:textOut) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

       dcl-Proc rSQL_lPad export;
          dcl-Pi *n varChar(30000);
             sourceIn varChar(30000) const;
             lengthIn int(10)        const;
             padIn    varChar(30)    const options(*noPass);
          end-Pi;

          dcl-S valueOut varChar(30000);
          dcl-S padWith  varChar(30) inz(' ');

          if (%parms() > 2);
             padWith = padIn;
          endIf;
          exec SQL
            values lpad(:sourceIn, :lengthIn, :padWith) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_max export;
          dcl-Pi *n varchar(500);
            var01 varchar(500) const;
            var02 varchar(500) const;
            var03 varchar(500) const options(*noPass);
            var04 varchar(500) const options(*noPass);
            var05 varchar(500) const options(*noPass);
            var06 varchar(500) const options(*noPass);
            var07 varchar(500) const options(*noPass);
            var08 varchar(500) const options(*noPass);
            var09 varchar(500) const options(*noPass);
            var10 varchar(500) const options(*noPass);
          end-Pi;

          dcl-S varOut varchar(500);

          if (%parms < 3);
             exec SQL
               values max(:var01, :var02)
               into :varOut;
          elseIf (%parms < 4);
             exec SQL
               values max(:var01, :var02, :var03)
               into :varOut;
          elseIf (%parms < 5);
             exec SQL
               values max(:var01, :var02, :var03, :var04)
               into :varOut;
          elseIf (%parms < 6);
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05)
               into :varOut;
          elseIf (%parms < 7);
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05,
                          :var06)
               into :varOut;
          elseIf (%parms < 8);
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07)
               into :varOut;
          elseIf (%parms < 9);
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08)
               into :varOut;
          elseIf (%parms < 10);
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09)
               into :varOut;
          else;
             exec SQL
               values max(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09, :var10)
               into :varOut;
          endIf;

          setCodes();
          return %trimR(varOut);
       end-Proc;

       dcl-Proc rSQL_midnight_Seconds export;
          dcl-Pi *n int(10);
            timeIn time(*ISO) const;
          end-Pi;

          dcl-S secondsOut int(10);

          exec SQL
            values midnight_Seconds(:timeIn) into :secondsOut;
          setCodes();
          return secondsOut;
       end-Proc;

       dcl-Proc rSQL_min export;
          dcl-Pi *n varchar(500);
            var01 varchar(500) const;
            var02 varchar(500) const;
            var03 varchar(500) const options(*noPass);
            var04 varchar(500) const options(*noPass);
            var05 varchar(500) const options(*noPass);
            var06 varchar(500) const options(*noPass);
            var07 varchar(500) const options(*noPass);
            var08 varchar(500) const options(*noPass);
            var09 varchar(500) const options(*noPass);
            var10 varchar(500) const options(*noPass);
          end-Pi;

          dcl-S varOut varchar(500);

          if (%parms < 3);
             exec SQL
               values min(:var01, :var02)
               into :varOut;
          elseIf (%parms < 4);
             exec SQL
               values min(:var01, :var02, :var03)
               into :varOut;
          elseIf (%parms < 5);
             exec SQL
               values min(:var01, :var02, :var03, :var04)
               into :varOut;
          elseIf (%parms < 6);
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05)
               into :varOut;
          elseIf (%parms < 7);
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05,
                          :var06)
               into :varOut;
          elseIf (%parms < 8);
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07)
               into :varOut;
          elseIf (%parms < 9);
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08)
               into :varOut;
          elseIf (%parms < 10);
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09)
               into :varOut;
          else;
             exec SQL
               values min(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09, :var10)
               into :varOut;
          endIf;

          setCodes();
          return %trimR(varOut);
       end-Proc;

       dcl-Proc rSQL_monthName export;
          dcl-Pi *n varchar(100);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S textOut varchar(100);

          exec SQL
            values monthName(:dateIn) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_next_Day export;
          dcl-Pi *n date;
            dateIn  date(*ISO)  const;
            nextDay varchar(20) const;
          end-Pi;

          dcl-S dateOut date(*ISO);

          exec SQL
            values next_Day(:dateIn, :nextDay) into :dateOut;
          setCodes();
          return dateOut;
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_PI export;
          dcl-Pi *n zoned(16:15) end-Pi;

          dcl-S valueOut zoned(16:15);

          exec SQL
            values PI() into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_quarter export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values quarter(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_radians export;
          dcl-Pi *n zoned(30:16);
            valueIn zoned(30:16) const;
          end-Pi;

          dcl-S valueOut zoned(30:16);

          exec SQL
            values round(radians(:valueIn), 16) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_rand export;
          dcl-Pi *n zoned(30:16);
            intIn int(10) const options(*noPass);
          end-Pi;

          dcl-S valueOut zoned(30:16);

          if (%parms() = 0);
             exec SQL
               values round(rand(), 16) into :valueOut;
          else;
             exec SQL
               values round(rand(:intIn), 16) into :valueOut;
          endIf;
          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_regExp_Count export;
          dcl-Pi *n int(10);
             source    varChar(30000) const;
             pattern   varChar(500)   const;
             startAtIn int(10)        const options(*noPass: *omit);
             flagsIn   varChar(50)    const options(*noPass: *omit);
          end-Pi;

          dcl-S startAt  int(10)     inz(1);
          dcl-S flags    varChar(50) inz('');
          dcl-S valueOut int(10);

          if (%parms() > 2 and %addr(startAtIn) <> *null);
             startAt = startAtIn;
          endIf;
          if (%parms() > 3 and %addr(flagsIn) <> *null);
             flags = flagsIn;
          endIf;

          exec SQL
             values regExp_Count(:source, :pattern, :startAt, :flags)
                into :valueOut;

          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_regExp_InStr export;
          dcl-Pi *n int(10);
             source      varChar(30000) const;
             pattern     varChar(500)   const;
             startAtIn   int(10)        const options(*noPass: *omit);
             occurenceIn int(10)        const options(*noPass: *omit);
             returnOptIn int(10)        const options(*noPass: *omit);
             flagsIn     varChar(50)    const options(*noPass: *omit);
             groupIn     int(10)        const options(*noPass: *omit);
          end-Pi;

          dcl-S startAt   int(10)     inz(1);
          dcl-S occurence int(10)     inz(1);
          dcl-S returnOpt int(10)     inz(0);
          dcl-S flags     varChar(50) inz('');
          dcl-S group     int(10)     inz(0);
          dcl-S valueOut  int(10);

          if (%parms() > 2 and %addr(startAtIn) <> *null);
             startAt = startAtIn;
          endIf;
          if (%parms() > 3 and %addr(occurenceIn) <> *null);
             occurence = occurenceIn;
          endIf;
          if (%parms() > 4 and %addr(returnOptIn) <> *null);
             returnOpt = returnOptIn;
          endIf;
          if (%parms() > 5 and %addr(flagsIn) <> *null);
             flags = flagsIn;
          endIf;
          if (%parms() > 6 and %addr(groupIn) <> *null);
             group = groupIn;
          endIf;

          exec SQL
             values regExp_InStr(:source,
                                 :pattern,
                                 :startAt,
                                 :occurence,
                                 :returnOpt,
                                 :flags,
                                 :group)
                into :valueOut;

          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_regExp_replace export;
          dcl-Pi *n varChar(30000);
             source      varChar(30000) const;
             pattern     varChar(500)   const;
             replacement varChar(30000) const;
             startAtIn   int(10)        const options(*noPass: *omit);
             occurenceIn int(10)        const options(*noPass: *omit);
             flagsIn     varChar(50)    const options(*noPass: *omit);
          end-Pi;

          dcl-S startAt   int(10)     inz(1);
          dcl-S occurence int(10)     inz(1);
          dcl-S flags     varChar(50) inz('');
          dcl-S valueOut  varChar(30000);

          if (%parms() > 3 and %addr(startAtIn) <> *null);
             startAt = startAtIn;
          endIf;
          if (%parms() > 4 and %addr(occurenceIn) <> *null);
             occurence = occurenceIn;
          endIf;
          if (%parms() > 5 and %addr(flagsIn) <> *null);
             flags = flagsIn;
          endIf;

          exec SQL
             values regExp_replace(:source,
                                   :pattern,
                                   :replacement,
                                   :startAt,
                                   :occurence,
                                   :flags)
                into :valueOut;

          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_regExp_SubStr export;
          dcl-Pi *n varChar(30000);
             source      varChar(30000) const;
             pattern     varChar(500)   const;
             startAtIn   int(10)        const options(*noPass: *omit);
             occurenceIn int(10)        const options(*noPass: *omit);
             flagsIn     varChar(50)    const options(*noPass: *omit);
             groupIn     int(10)        const options(*noPass: *omit);
          end-Pi;

          dcl-S startAt   int(10)     inz(1);
          dcl-S occurence int(10)     inz(1);
          dcl-S flags     varChar(50) inz('');
          dcl-S group     int(10)     inz(0);
          dcl-S valueOut  varChar(30000);

          if (%parms() > 2 and %addr(startAtIn) <> *null);
             startAt = startAtIn;
          endIf;
          if (%parms() > 3 and %addr(occurenceIn) <> *null);
             occurence = occurenceIn;
          endIf;
          if (%parms() > 4 and %addr(flagsIn) <> *null);
             flags = flagsIn;
          endIf;
          if (%parms() > 5 and %addr(groupIn) <> *null);
             group = groupIn;
          endIf;

          exec SQL
             values regExp_SubStr(:source,
                                  :pattern,
                                  :startAt,
                                  :occurence,
                                  :flags,
                                  :group)
                into :valueOut;

          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_replace export;
          dcl-Pi *n varChar(30000);
             source  varChar(30000) const;
             search  varChar(30000) const;
             replace varChar(30000) const;
          end-Pi;

          dcl-S valueOut varChar(30000);

          exec SQL
             values replace(:source, :search, :replace) into :valueOut;

          setCodes();
          return %trimR(valueOut);
       end-Proc;

       dcl-Proc rSQL_right export;
          dcl-Pi *n varchar(32000);
            stringIn varchar(32000) const;
            forLengthIn int(10) const;
          end-Pi;

          dcl-S stringOut varchar(32000);
          dcl-S getLength int(10);

          getLength = forLengthIn;
          if (%len(stringIn) < getLength);
             getLength = %len(stringIn);
          endIf;
          if (getLength > 0);
             exec SQL
               values right(:stringIn, :getLength) into :stringOut;
             setCodes();
          endIf;
          return %trimR(stringOut);
       end-Proc;

       dcl-Proc rSQL_round_TimeStamp export;
          dcl-Pi *n timestamp;
            stampIn     timestamp  const;
            stampFormat varchar(5) const;
          end-Pi;

          dcl-S stampOut timestamp;

          exec SQL
            values round_TimeStamp(:stampIn, :stampFormat) into :stampOut;
          setCodes();
          return StampOut;
       end-Proc;

       dcl-Proc rSQL_rPad export;
          dcl-Pi *n varChar(30000);
             sourceIn varChar(30000) const;
             lengthIn int(10)        const;
             padIn    varChar(30)    const options(*noPass);
          end-Pi;

          dcl-S valueOut varChar(30000);
          dcl-S padWith  varChar(30) inz(' ');

          if (%parms() > 2);
             padWith = padIn;
          endIf;
          exec SQL
            values rpad(:sourceIn, :lengthIn, :padWith) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_set_Encryption_Password export;
          dcl-Pi *n;
            passwordIn varchar(127) const;
            hintIn     varchar(32)  const options(*noPass);
          end-Pi;

          dcl-S password varchar(127) inz('       ');
          dcl-S hint     varchar(32);

          password = %trimR(passwordIn);
          if (%len(password) < 6);
             %len(password) = 6;
          endIf;
          if (%parms() < 2);
             exec SQL
               set encryption password = :password;
          else;
             hint = %trimR(hintIn);
             exec SQL
               set encryption password = :password with hint :hint;
          endIf;
          setCodes();
          return;
       end-Proc;

       dcl-Proc rSQL_sin export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values sin(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_sinh export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values sinh(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_soundex export;
          dcl-Pi *n char(4);
            valueIn varchar(32000) const;
          end-Pi;

          dcl-S valueOut char(4);

          exec SQL
            values soundex(:valueIn) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_tan export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values tan(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_tanh export;
          dcl-Pi *n zoned(30:16);
            numIn zoned(30:16) const;
          end-Pi;

          dcl-S numOut zoned(30:16);

          exec SQL
            values tanh(:numIn) into :numOut;
          setCodes();
          return numOut;
       end-Proc;

       dcl-Proc rSQL_truncate export;
          dcl-Pi *n packed(30:15);
            valueIn  packed(30:15) const;
            placesIn int(10)       const options(*noPass);
          end-Pi;

          dcl-S places   int(10);
          dcl-S valueOut packed(30:15);

          if (%parms() > 1);
             places = placesIn;
          endIf;

          exec SQL
            values truncate(:valueIn, :places) into :valueOut;
          setCodes();
          return valueOut;
       end-Proc;

       dcl-Proc rSQL_trunc_TimeStamp export;
          dcl-Pi *n timestamp;
            stampIn     timestamp  const;
            stampFormat varchar(5) const;
          end-Pi;

          dcl-S stampOut timestamp;

          exec SQL
            values trunc_TimeStamp(:stampIn, :stampFormat) into :stampOut;
          setCodes();
          return StampOut;
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_ucase export;
          dcl-Pi *n varchar(32000);
            textIn varchar(32000) const;
          end-Pi;

          dcl-S textOut varchar(32000);

          textOut = %trimR(textIn);
          exec SQL
            values ucase(:textOut) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;


       dcl-Proc rSQL_upper export;
          dcl-Pi *n varchar(32000);
            textIn varchar(32000) const;
          end-Pi;

          dcl-S textOut varchar(32000);

          textOut = %trimR(textIn);
          exec SQL
            values upper(:textOut) into :textOut;
          setCodes();
          return %trimR(textOut);
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_value export;
          dcl-Pi *n varchar(1000);
            value01In varchar(1000) const  options(*noPass: *Omit);
            value02In varchar(1000) const  options(*noPass: *Omit);
            value03In varchar(1000) const  options(*noPass: *Omit);
            value04In varchar(1000) const  options(*noPass: *Omit);
            value05In varchar(1000) const  options(*noPass: *Omit);
            value06In varchar(1000) const  options(*noPass: *Omit);
            value07In varchar(1000) const  options(*noPass: *Omit);
            value08In varchar(1000) const  options(*noPass: *Omit);
            value09In varchar(1000) const  options(*noPass: *Omit);
            value10In varchar(1000) const  options(*noPass: *Omit);
          end-Pi;

          dcl-S valueOut varchar(1000);
          dcl-S value01  varchar(1000);
          dcl-S value02  varchar(1000);
          dcl-S value03  varchar(1000);
          dcl-S value04  varchar(1000);
          dcl-S value05  varchar(1000);
          dcl-S value06  varchar(1000);
          dcl-S value07  varchar(1000);
          dcl-S value08  varchar(1000);
          dcl-S value09  varchar(1000);
          dcl-S value10  varchar(1000);

          if ((%parms() >= 1) and (%addr(value01In) <> *null));
             value01 = %trimR(value01In);
          endIf;
          if ((%parms() >= 2) and (%addr(value02In) <> *null));
             value02 = %trimR(value02In);
          endIf;
          if ((%parms() >= 3) and (%addr(value03In) <> *null));
             value03 = %trimR(value03In);
          endIf;
          if ((%parms() >= 4) and (%addr(value04In) <> *null));
             value04 = %trimR(value04In);
          endIf;
          if ((%parms() >= 5) and (%addr(value05In) <> *null));
             value05 = %trimR(value05In);
          endIf;
          if ((%parms() >= 6) and (%addr(value06In) <> *null));
             value06 = %trimR(value06In);
          endIf;
          if ((%parms() >= 7) and (%addr(value07In) <> *null));
             value07 = %trimR(value07In);
          endIf;
          if ((%parms() >= 8) and (%addr(value08In) <> *null));
             value08 = %trimR(value08In);
          endIf;
          if ((%parms() >= 9) and (%addr(value09In) <> *null));
             value09 = %trimR(value09In);
          endIf;
          if ((%parms() >= 10) and (%addr(value10In) <> *null));
             value10 = %trimR(value10In);
          endIf;

          exec SQL
            values value(case :value01
                           when '' then cast(null as char)
                           else :value01 end,
                         case :value02
                           when '' then cast(null as char)
                           else :value02 end,
                         case :value03
                           when '' then cast(null as char)
                           else :value03 end,
                         case :value04
                           when '' then cast(null as char)
                           else :value04 end,
                         case :value05
                           when '' then cast(null as char)
                           else :value05 end,
                         case :value06
                           when '' then cast(null as char)
                           else :value06 end,
                         case :value07
                           when '' then cast(null as char)
                           else :value07 end,
                         case :value08
                           when '' then cast(null as char)
                           else :value08 end,
                         case :value09
                           when '' then cast(null as char)
                           else :value09 end,
                         case :value10
                           when '' then cast(null as char)
                           else :value10 end)
               into :valueOut;

          setCodes();
          return %trimR(valueOut);
       end-Proc;

        //----------------------------------------------------------------------

       dcl-Proc rSQL_week export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values week(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

       dcl-Proc rSQL_week_ISO export;
          dcl-Pi *n int(5);
            dateIn date(*ISO) const;
          end-Pi;

          dcl-S dayOut int(5);

          exec SQL
            values week_ISO(:dateIn) into :dayOut;
          setCodes();
          return dayOut;
       end-Proc;

        //---------------------------------------------------------

       dcl-Proc rSQL_xor export;
          dcl-Pi *n varchar(1000);
            var01 varchar(500) const;
            var02 varchar(500) const;
            var03 varchar(500) const options(*noPass);
            var04 varchar(500) const options(*noPass);
            var05 varchar(500) const options(*noPass);
            var06 varchar(500) const options(*noPass);
            var07 varchar(500) const options(*noPass);
            var08 varchar(500) const options(*noPass);
            var09 varchar(500) const options(*noPass);
            var10 varchar(500) const options(*noPass);
          end-Pi;

          dcl-S varOut varchar(1000) inz('');
          dcl-S maxArr int(10)       dim(10);
          dcl-S lenOut int(10);

          if (%parms() > 9);
             maxArr(10) = %len(var10);
          endIf;
          if (%parms() > 8);
             maxArr(9) = %len(var09);
          endIf;
          if (%parms() > 7);
             maxArr(8) = %len(var08);
          endIf;
          if (%parms() > 6);
             maxArr(7) = %len(var07);
          endIf;
          if (%parms() > 5);
             maxArr(6) = %len(var06);
          endIf;
          if (%parms() > 4);
             maxArr(5) = %len(var05);
          endIf;
          if (%parms() > 3);
             maxArr(4) = %len(var04);
          endIf;
          if (%parms() > 2);
             maxArr(3) = %len(var03);
          endIf;
          if (%parms() > 1);
             maxArr(2) = %len(var02);
          endIf;
          if (%parms() > 0);
             maxArr(1) = %len(var01);
          endIf;
          lenOut = set_MaxLength(maxArr);

          if (%parms < 3);
             exec SQL
               values xor(:var01, :var02)
               into :varOut;
          elseIf (%parms < 4);
             exec SQL
               values xor(:var01, :var02, :var03)
               into :varOut;
          elseIf (%parms < 5);
             exec SQL
               values xor(:var01, :var02, :var03, :var04)
               into :varOut;
          elseIf (%parms < 6);
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05)
               into :varOut;
          elseIf (%parms < 7);
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05,
                          :var06)
               into :varOut;
          elseIf (%parms < 8);
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07)
               into :varOut;
          elseIf (%parms < 9);
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08)
               into :varOut;
          elseIf (%parms < 10);
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09)
               into :varOut;
          else;
             exec SQL
               values xor(:var01, :var02, :var03, :var04, :var05,
                          :var06, :var07, :var08, :var09, :var10)
               into :varOut;
          endIf;

          setCodes();
          %len(varOut) = lenOut;
          return varOut;
       end-Proc;
